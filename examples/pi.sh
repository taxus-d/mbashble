#!/bin/bash

#pi.sh: вычисление числа π методом случайной стрельбы

#  этот скрипт -- простая реализация метода Монте-Карло:
#+ решение какой-либо достаточно вычислительной задачки 
#+ с использованием случайных чисел.
#  Например, народ таким способом ищет интергралы,
#+ кидая случайную точку под график кривой.
#  Обычно это бывает нужно, когда аналитического 
#+ способа оценить что-либо просто нет.
#  Например в подборе параметров для атмосферы звезды.
#  Но у нас всё сильно проще

#  Рассмотрим идеально квадратный остров.
#+ с идеально круглым озером в центре.
#  В основном у нас везде вода кроме 4 уголков.
#  (Считайте, что окружность вписана в квадрат) 

#  Будем случайным образом 
#+ стрелять ядрами из старой пушки по острову.
#  Все выстрелы либо булькаются в воду, либо 
#+ ударяются о грунт.

#  При достаточном количестве выстрелов вероятность
#+ попадания в воду стремится к π/4 (отношение площадей)
#  На самом деле мы будем стрелять только в четверть
#+ квадратика ( у нас нет отрицательных чисел из-за 
#+ ограничений языка оболочки )

#  В теории, чем больше выстрелов произведено,
#  тем точнее совпадение. Однако в скрипте на языке оболочки,
#+ в отличие от серьёзного языка со встроенной математикой
#+ нам придётся пойти на компромисс. 
#  Это сделает вычисления менее аккуратными


DIMENSION=10000 # половина стороны острова

MAXSHOTS=100 # количество выстрелов

PIFACTOR=4.0 # нам нужно в конце из π/4 получить π

readonly M_PI=3.141592654 # эталон для сравнения

get_random() {
    # делаем случайное число
    random=$(od -A n -t d -N 3 /dev/urandom)
    #  комманда `od` вообще умеет печать на экран бинарные файлы в 
    #+ понятном человеку виде (urandom таки файл). Что делаеют флаги:
    #+ -A n -- не печатай сдвиг в файле
    #+ -t d -- нужны десятичные числа
    #+ -N 3 -- хотим 3 байта хлама
    let "rnum = $random % $DIMENSION" # считаем остаток по модулю
    #+ задаём там  самым границы случайного числа чтобы не 
    #+ вылезти за край острова
    
    echo $rnum # печатаем
}

distance=0 #  глобальная переменная задающая расстояние

#  эта чудесная функция каждый раз считает значение
#+ расстояния от точки (0,0) - центр острова
#+ по заданным координатам
hypotenuse() { 
    distance=$(echo "scale=0; sqrt($1*$1 + $2*$2)" | bc -l)
#   команды для bc :    ^     ^                       ^
#   количество цифр после     ^                       ^
#   запятой ( ну не может     ^                       ^
#   Bash в нецелые числа)     ^                       ^
#                          извлекаем корень из суммы  ^
#                          квадратов                  ^
#                          переданных координат       ^
#                          ($1 $2 в теле функции      ^
#                          хранят значение её         ^
#                          аргументов а не параметров ^
#                          скрипта                    ^
# а тут отдаём всё на вход bc с подключёнными математическими
# библиотеками (флаг -l)
}

#  это для красоты сделан аналог гланой программы
#+ в нормальных языках программирования
# main() {
shots=0    # число выстрелов
splashes=0 # количество попаданий в воду
thuds=0    # количество попаданий не в воду
pi=0       # текущее значение π
error=0    # погрешность вычислений

while [ "$shots" -lt "$MAXSHOTS" ]
do
    # получаем случайные координаты
    xCoord=$(get_random) 
    yCoord=$(get_random)

    # считаем расстояние до центра
    hypotenuse $xCoord $yCoord
    
    #  (( ... )) -- целочисленная арифметика
    #+ с похожим на С синтаксисом 
    (( shots++ ))

    # тут красиво печатаем что получилось в шаге цикла
    printf "#%4d   " $shots
    printf "Xc = %4d   " $xCoord
    printf "Yc = %4d   " $yCoord
    printf "Distance = %5d " $distance
    printf "%5d " $splashes

    # проверяем куда попало ядро 
    if [ $distance -le $DIMENSION ]
    then
        (( splashes++ ))
    else
        (( thuds++ ))
    fi
    # считаем текущее значение π
    pi=$(echo "scale=9; $PIFACTOR*$splashes/$shots" | bc)
    #  Кстати, $чтототам в командах такого сорта 
    #+ (a=$(cmd1 $param1 | cmd2) ) 
    #+ ни в коем случае прямо так не отдаётся
    #+ интерпретатору , а сначала всё заменяется 
    #+ значениями. 
    
    echo -n "PI ~ $pi"
    echo # <- это тоже для красоты


done

# считаем отклонение от эталона (M_PI)
error=$(echo "scale=9; $pi - $M_PI" | bc)
# переводим в проценты
pct_error=$(echo "scale=2; 100.0 * $error / $M_PI" | bc)
echo -n "Deviation from mathematical value of PI =
$error"
echo " ($pct_error% error)"
echo
# } конец, всё закончилось успешно, возвращаем 0
exit 0



